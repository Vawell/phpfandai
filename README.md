# phpfandai
简单的php基于curl的反向代理程序

经理：需要实现一个反向代理？  

我：  简单，nginx分分钟配置好。      

经理：嗯？没有nginx？      

我： nodejs也行啊，网上有例子分分钟搞定。

经理：嗯？只有虚拟主机，只能上传php程序？

我：Oh，My god！

于是就有了一个php写的反向代理程序就诞生了

 

 

什么是反向代理：

百度百科有云：

反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。

反向代理目的也各有不同，有用作CDN的，有作为负载均衡的等等。

成熟的反向代理的软件有很多：我比较熟悉nginx，性能高，功能强大，配置简单，作为负载均衡的工具绝对是杠杠的。

作为一个程序员，以上都是废话，下面进入正题。

为了快速的完成功能（其实就是懒），我首先做的就是google，看看是否有php实现的反向打理程序。事实上还真找到了。有7ghost、phpproxy等等，可惜他们要不是用fsockopen写的。我不是很看得懂，看不懂，就很难修改和扩展，更好的为自己的需求工作，要不就是功能上好像有些不符合我们的一些测试。于是一咬牙就写了php基于curl的反向代理脚本。

php是一个脚本语言，也就是说它的执行效率肯定是不如C，也不如JS，而且传统的php也无法利用事件驱动IO，所以在性能上无法和nginx、nodejs实现的程序相比，如果条件允许，优先使用更好的实现工具。

但是不得以只能使用的情况下，提高性能就是必须的了。而提高性能的秘密就是少做事，只做一件事，那就是做好请求数据的搬运工，保留HTTP的美好的特性，比如：浏览器缓存，gzip压缩，但是php不做额外的操作，比如：负载均衡，根据缓存头缓存内容等。

实现的逻辑主要就是一下三步：

1. 从$_SERVER获取浏览器请求的内容，传说中的Request，并进行一些修改。

2. 用curl将Request发到后端机器上，并等待后端的返回内容 传说中的Response。

3. Response中包含Header和Body，分别用header函数和echo函数将它们发到浏览器渲染。

4. 用rewrite规则将请求发给index.php上执行，这个很容易，代码就不贴了。

代码地址如下：

https://gitee.com/jamesren_781/codes/e9v45qa68wndrzbh3ktof

题外话：我曾经看到我的同事写过一个类似反向代理的实现功能，使用的方法很简单：

echo file_get_contents($url);
后来发现如果url是一个图片的话不行，因为content-type不对，浏览器无法识别。结果写了一套根据url后缀识别content-type的方法，等于是实现了一套服务器规则，使得浏览器显示正常了，当时他还得意了很久。这种实现丢失了很多好的东西，比如缓存，gzip等等，还白白浪费了性能。
